// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Benchmarks.Readers;
using Newtonsoft.Json;
using NuGet.Common;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;

namespace NuGet.Protocol
{
    public class VulnerabilityInfoResource : INuGetResource
    {
        private readonly HttpSource _client;
        private readonly Uri _vulnerabilityEndpoint;
        private readonly ServiceIndexEntry _vulnerabilityServiceIndexEntry;
        private Dictionary<string, PackageMetadata> _vulnerablePackages;

        public VulnerabilityInfoResource(HttpSource client, ServiceIndexEntry vulnerabilityServiceIndexEntry)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _vulnerabilityServiceIndexEntry = vulnerabilityServiceIndexEntry ?? throw new ArgumentNullException(nameof(vulnerabilityServiceIndexEntry));
            _vulnerabilityEndpoint = vulnerabilityServiceIndexEntry.Uri;
        }

        public async Task<Dictionary<string, PackageMetadata>> GetAllPackageVulnerabilityInformationAsync(
            ILogger log,
            CancellationToken cancellationToken)
        {
            if (log == null) throw new ArgumentNullException(nameof(log));
            await EnsurePackageVulnerabilitiesInfoAsync(log, cancellationToken);
            return _vulnerablePackages;
        }

        private async Task<bool> EnsurePackageVulnerabilitiesInfoAsync(ILogger log, CancellationToken cancellationToken)
        {
            var cacheKey = GenerateCacheKey(_vulnerabilityServiceIndexEntry);

            const int maxRetries = 3;
            for (var retry = 1; retry <= maxRetries; retry++)
            {
                using var sourceCacheContext = new SourceCacheContext();
                var httpSourceCacheContext = HttpSourceCacheContext.Create(sourceCacheContext, isFirstAttempt: retry == 1);

                try
                {
                    _vulnerablePackages = await GetVulnerabilityInformationAsync(
                    (httpSource, uri) => httpSource.GetAsync(
                        request: new HttpSourceCachedRequest(
                                    uri.AbsoluteUri,
                                    cacheKey,
                                    httpSourceCacheContext)
                        {
                            EnsureValidContents = stream => HttpStreamValidation.ValidateJObject(_vulnerabilityEndpoint.AbsoluteUri, stream),
                            MaxTries = 1,
                            IsRetry = retry > 1,
                            IsLastAttempt = retry == maxRetries
                        },
                        processAsync: async httpSourceResult =>
                        {
                            return await ProcessStreamAsync(httpSourceResult.Stream);
                        },
                        log: log,
                        token: cancellationToken),
                    log,
                    cancellationToken);
                    break;
                }
                catch (Exception ex) when (retry < maxRetries)
                {
                    var message = string.Format(CultureInfo.CurrentCulture, Strings.Log_RetryingHttp, HttpMethod.Get, _vulnerabilityEndpoint.AbsoluteUri)
                        + Environment.NewLine
                        + ExceptionUtilities.DisplayMessage(ex);
                    log.LogMinimal(message);
                }
                catch (Exception ex) when (retry == maxRetries)
                {
                    var message = string.Format(CultureInfo.CurrentCulture, Strings.Log_FailedToReadVulnerabilityInformation, _vulnerabilityEndpoint.AbsoluteUri);

                    throw new FatalProtocolException(message, ex);
                }
            }
            return true;

            static string GenerateCacheKey(ServiceIndexEntry serviceEntry)
            {
#if NETCOREAPP
            var index = serviceEntry.Type.IndexOf('/', StringComparison.Ordinal);
#else
                var index = serviceEntry.Type.IndexOf('/');
#endif
                var version = serviceEntry.Type.Substring(index + 1).Trim();

                return $"vulnerability_info_{version}";
            }
        }

        private async Task<T> GetVulnerabilityInformationAsync<T>(
            Func<HttpSource, Uri, Task<T>> getResultAsync,
            ILogger log,
            CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var endpoint = _vulnerabilityEndpoint;

            var queryUrl = new UriBuilder(endpoint.AbsoluteUri);

            T searchResult;
            try
            {
                log.LogVerbose($"Querying {queryUrl.Uri}");

                searchResult = await getResultAsync(_client, queryUrl.Uri);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (JsonReaderException ex)
            {
                throw new FatalProtocolException(string.Format(CultureInfo.CurrentCulture, Strings.Protocol_MalformedMetadataError, queryUrl.Uri), ex);
            }
            catch (HttpRequestException ex)
            {
                throw new FatalProtocolException(string.Format(CultureInfo.CurrentCulture, Strings.Protocol_BadSource, queryUrl.Uri), ex);
            }

            if (searchResult != null)
            {
                return searchResult;
            }

            throw new FatalProtocolException("Something went really really really wrong :D");
        }


        private static Task<Dictionary<string, PackageMetadata>> ProcessStreamAsync(Stream stream)
        {
            using var streamReader = new StreamReader(stream);
            using var jsonReader = new JsonTextReader(streamReader);
            var vulnerabilities = GenerateVulnerabilities(jsonReader);
            return Task.FromResult(vulnerabilities);
        }

        static Dictionary<string, PackageMetadata> GenerateVulnerabilities(JsonTextReader jsonReader)
        {
            Dictionary<string, PackageMetadata> results = new();

            jsonReader.ReadObject(packageId =>
            {
                var metadata = new PackageMetadata(packageId);
                jsonReader.ReadObject(packageVersion =>
                {
                    var versionMetadata = new PackageVersionMetadata(NuGetVersion.Parse(packageVersion));
                    if (jsonReader.ReadNextToken() && jsonReader.TokenType == JsonToken.StartArray)
                    {
                        do
                        {
                            int severity = 0;
                            string advisoryUrl = null;
                            jsonReader.ReadObject(propertyName =>
                            {
                                switch (propertyName)
                                {
                                    case "severity":
                                        severity = (int)jsonReader.ReadAsInt32();
                                        break;
                                    case "advisoryUrl":
                                        advisoryUrl = jsonReader.ReadNextTokenAsString();
                                        break;
                                    default:
                                        break;
                                }
                            });

                            if (jsonReader.TokenType == JsonToken.EndArray)
                            {
                                break;
                            }
                            versionMetadata.Vulnerabilities.Add((new Uri(advisoryUrl), severity));
                        }
                        while (jsonReader.TokenType == JsonToken.EndObject);
                        metadata.Version.Add(versionMetadata);
                    }
                });
                results.Add(packageId, metadata);
            });
            return results;
        }

        public class PackageMetadata
        {
            public string Id { get; private set; }

            public List<PackageVersionMetadata> Version { get; } = new();
            public PackageMetadata(string id)
            {
                Id = id;
            }
        }

        public class PackageVersionMetadata
        {
            public PackageVersionMetadata(NuGetVersion version)
            {
                Version = version;
            }
            public NuGetVersion Version { get; private set; }

            public List<(Uri, int)> Vulnerabilities { get; } = new();
        }
    }
}
